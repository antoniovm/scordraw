package scorbot.src;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.util.*;

import javax.comm.*;

import org.omg.CORBA.OMGVMCID;
public class Scortbot {

public static void main(String[] args) throws IOException, UnsupportedCommOperationException, PortInUseException {
	List<CommPortIdentifier> puertosSerie = new LinkedList<CommPortIdentifier>();
	Enumeration<CommPortIdentifier> listaPuertos = CommPortIdentifier.getPortIdentifiers();
	
	SerialPort com6=null;
	
	//comprobamos todos los puertos y listamos los serie y paralelo
	while(listaPuertos.hasMoreElements()){
		CommPortIdentifier portId = listaPuertos.nextElement();
		System.out.print(portId.getName()+"-");
		if(portId.getPortType() == CommPortIdentifier.PORT_SERIAL){ //== 1
			System.out.println("Puerto Serie ("+portId.getPortType()+")");
			puertosSerie.add(portId); //si es serie, lo guardamos en la lista
		}
		if(portId.getPortType() == CommPortIdentifier.PORT_PARALLEL) //==2
			System.out.println("Puerto Paralelo ("+portId.getPortType()+")");
	}
	
	Iterator<CommPortIdentifier> it = puertosSerie.iterator();
	List<SerialPort> pSerieOpen = new LinkedList<SerialPort>();
	CommPortIdentifier puertoActual;
	System.out.println("\nPRUEBA");
	
	/*Comprobamos si los puertos serie estan siendo utilizado por
	 * alguna aplicacion e intentamos abrir los 3 (cambiarlo en clase)
	 * para inicializarlos como SerialPort*/
	while(it.hasNext()){
		puertoActual = it.next();
		System.out.println(puertoActual.getName());
		if(puertoActual.getName().equals("COM6"))
			if(!puertoActual.isCurrentlyOwned())
				com6 = (SerialPort)puertoActual.open(puertoActual.getName(), 5000);
		
			
	}
	
	
	
	//com6.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);
	OutputStream osCom6 = com6.getOutputStream();
	InputStream isCom6 = com6.getInputStream();
	String comando="";
	while(true){
		System.out.print("\n>");
		//comando=(new BufferedReader(new InputStreamReader(System.in))).readLine()+'\r';
	
	//osCom4.write();
	byte[] bufferLectura = new byte[256];
	
	//for (int i = 0; i < comando.length(); i++) {
		isCom6.read(bufferLectura);
		osCom6.write(new String(bufferLectura).trim().getBytes());
		System.out.println(new String(bufferLectura).trim());
	//}
	//osCom6.write(new String("Done.\n>").getBytes());
	
	}
	//---------------------------------------

}

}

/*
 * INFORMACIÓN VARIA
 * 
 * COMMPORTIDENTIFIER
 * Communications port management. CommPortIdentifier is the central
 * class for controlling access to communications ports. It includes methods for: 
 * Determining the communications ports made available by the driver. 
 * Opening communications ports for I/O operations. 
 * Determining port ownership. 
 * Resolving port ownership contention. 
 * Managing events that indicate changes in port ownership status. 

 * An application first uses methods in CommPortIdentifier to negotiate
 * with the driver to discover which communication ports are available and then select a port for opening. It then uses methods in other classes like CommPort, ParallelPort and SerialPort to communicate through the port.
 * 
 * 
 * getPortIdentifiers
 * public static java.util.Enumeration getPortIdentifiers()
 * Obtains an enumeration object that contains a CommPortIdentifier object for each port in the system. 
 * 
 * 
 * 
 * COMMPORT
 * extends java.lang.Object

 * A communications port. CommPort is an abstract class that describes a
 * communications port made available by the underlying system. It includes
 * high-level methods for controlling I/O that are common to different kinds
 * of communications ports. SerialPort and ParallelPort are subclasses of
 * CommPort that include additional methods for low-level control of
 * physical communications ports. 

 * There are no public constructors for CommPort. Instead an application
 * should use the static method CommPortIdentifier.getPortIdentifiers
 * to generate a list of available ports. It then chooses a port from
 * this list and calls CommPortIdentifier.open to create a CommPort object.
 * Finally, it casts the CommPort object to a physical communications
 * device class like SerialPort or ParallelPort. 

 * After a communications port has been identified and opened it can be
 * configured with the methods in the low-level classes like SerialPort
 * and ParallelPort. Then an IO stream can be opend for reading and
 * writing data. Once the application is done with the port, it must call
 * the close method. Thereafter the application must not call any methods
 * in the port object. Doing so will cause a java.lang.IllegalStateException to be thrown.
 * 
 * 
 * 
 * AddEventListener
 * All the events received by this listener are generated by
 * one dedicated thread that belongs to the SerialPort object.
 * After the port is closed, no more event will be generated.
 * Another call to open() of the port's CommPortIdentifier object
 * will return a new CommPort object, and the lsnr has to be added
 * again to the new CommPort object to receive event from this port.
 * 
 * 
 * NotifyOnDataAvailable
 * Expresses interest in receiving notification when input data is available.
 * This may be used to drive asynchronous input. When data is available in the
 * input buffer, this event is propagated to the listener registered using addEventListener. 
 * The event will be generated once when new data arrive at the serial port. Even if
 * the user doesn't read the data, it won't be generated again until next time new data arrive
 * 
 * 
 * */